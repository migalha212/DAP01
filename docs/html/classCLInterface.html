<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA2025_PRJ1_G0608: CLInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DA2025_PRJ1_G0608
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classCLInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CLInterface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="CLInterface_8h_source.html">CLInterface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a358a9b97ca9295425be3e4095c3b6e70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#a358a9b97ca9295425be3e4095c3b6e70">presentUI</a> (const std::string &amp;locations, const std::string &amp;distances, std::ostream &amp;outFile)</td></tr>
<tr class="memdesc:a358a9b97ca9295425be3e4095c3b6e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents a user interface for selecting different planning modes.  <a href="classCLInterface.html#a358a9b97ca9295425be3e4095c3b6e70">More...</a><br /></td></tr>
<tr class="separator:a358a9b97ca9295425be3e4095c3b6e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614b7e6812ce759c8ec6dabd3882315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#ad614b7e6812ce759c8ec6dabd3882315">defaultRun</a> (const std::string &amp;locations, const std::string &amp;distances, const std::string &amp;inputFile, const std::string &amp;outputFile)</td></tr>
<tr class="memdesc:ad614b7e6812ce759c8ec6dabd3882315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the default run of the program, parsing location, distance, and input files to populate a graph and process the input.  <a href="classCLInterface.html#ad614b7e6812ce759c8ec6dabd3882315">More...</a><br /></td></tr>
<tr class="separator:ad614b7e6812ce759c8ec6dabd3882315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080d8feec666613c85e66f5dbe562f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#a080d8feec666613c85e66f5dbe562f9e">outPutIndependentResult</a> (Vertex&lt; int &gt; *sNode, Vertex&lt; int &gt; *dNode, Graph&lt; int &gt; *g, std::ostream &amp;outFile)</td></tr>
<tr class="memdesc:a080d8feec666613c85e66f5dbe562f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the independent route planning results based on the given parameters..  <a href="classCLInterface.html#a080d8feec666613c85e66f5dbe562f9e">More...</a><br /></td></tr>
<tr class="separator:a080d8feec666613c85e66f5dbe562f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa799e5075fdf9a550e8e5436341ab527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#aa799e5075fdf9a550e8e5436341ab527">outPutRestrictedResult</a> (Vertex&lt; int &gt; *sNode, Vertex&lt; int &gt; *dNode, std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;<a class="el" href="ParseFile_8cpp.html#a7dc6fef0daa34f843b7b6716f7998d23">nAvoid</a>, std::vector&lt; Edge&lt; int &gt; * &gt; &amp;<a class="el" href="ParseFile_8cpp.html#a5fa002daaf6ceb3453aaba36cf77b35d">eAvoid</a>, Vertex&lt; int &gt; *<a class="el" href="ShortestPathAlgorithms_8cpp.html#ac805e767cbf452db979787c2f474d0c1">must</a>, Graph&lt; int &gt; *g, std::ostream &amp;outFile)</td></tr>
<tr class="memdesc:aa799e5075fdf9a550e8e5436341ab527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the result of a restricted path query operation to a file or standard cout.  <a href="classCLInterface.html#aa799e5075fdf9a550e8e5436341ab527">More...</a><br /></td></tr>
<tr class="separator:aa799e5075fdf9a550e8e5436341ab527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e43cfaeb12d2d2077359c09eacfcf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#a9e43cfaeb12d2d2077359c09eacfcf30">outPutEcoResult</a> (Vertex&lt; int &gt; *sNode, Vertex&lt; int &gt; *dNode, std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;<a class="el" href="ParseFile_8cpp.html#a7dc6fef0daa34f843b7b6716f7998d23">nAvoid</a>, std::vector&lt; Edge&lt; int &gt; * &gt; &amp;<a class="el" href="ParseFile_8cpp.html#a5fa002daaf6ceb3453aaba36cf77b35d">eAvoid</a>, const double &amp;maxWalkTime, const bool &amp;aprox, Graph&lt; int &gt; *g, std::ostream &amp;outFile)</td></tr>
<tr class="memdesc:a9e43cfaeb12d2d2077359c09eacfcf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the eco-friendly route planning results based on the given parameters.  <a href="classCLInterface.html#a9e43cfaeb12d2d2077359c09eacfcf30">More...</a><br /></td></tr>
<tr class="separator:a9e43cfaeb12d2d2077359c09eacfcf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aff62b6a34249f957b6002c948f3212bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#aff62b6a34249f957b6002c948f3212bd">outputPath</a> (std::vector&lt; int &gt; &amp;v, std::ostream &amp;out)</td></tr>
<tr class="separator:aff62b6a34249f957b6002c948f3212bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848f524b478f02655dc71fc52b784364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#a848f524b478f02655dc71fc52b784364">independantRoute</a> (Graph&lt; int &gt; *g, std::ostream &amp;outFile, const std::string &amp;locations, const std::string &amp;distances)</td></tr>
<tr class="memdesc:a848f524b478f02655dc71fc52b784364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the independent route planning functionality in the command-line interface.  <a href="classCLInterface.html#a848f524b478f02655dc71fc52b784364">More...</a><br /></td></tr>
<tr class="separator:a848f524b478f02655dc71fc52b784364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ada6e7711678bf1f038a0f18ffd5e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#a5ada6e7711678bf1f038a0f18ffd5e80">restrictedRoute</a> (Graph&lt; int &gt; *g, std::ostream &amp;outFile, const std::string &amp;locations, const std::string &amp;distances)</td></tr>
<tr class="memdesc:a5ada6e7711678bf1f038a0f18ffd5e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the restricted route planning functionality in the command-line interface.  <a href="classCLInterface.html#a5ada6e7711678bf1f038a0f18ffd5e80">More...</a><br /></td></tr>
<tr class="separator:a5ada6e7711678bf1f038a0f18ffd5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776d320110110bd63592b09990d72709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLInterface.html#a776d320110110bd63592b09990d72709">ecoFriendlyRoute</a> (Graph&lt; int &gt; *g, std::ostream &amp;outFile, const std::string &amp;locations, const std::string &amp;distances)</td></tr>
<tr class="memdesc:a776d320110110bd63592b09990d72709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the Eco-friendly route planning functionality in the command-line interface.  <a href="classCLInterface.html#a776d320110110bd63592b09990d72709">More...</a><br /></td></tr>
<tr class="separator:a776d320110110bd63592b09990d72709"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad614b7e6812ce759c8ec6dabd3882315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad614b7e6812ce759c8ec6dabd3882315">&#9670;&nbsp;</a></span>defaultRun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::defaultRun </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the default run of the program, parsing location, distance, and input files to populate a graph and process the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locations</td><td>Path to the locations file. If empty, a default file is used. </td></tr>
    <tr><td class="paramname">distances</td><td>Path to the distances file. If empty, a default file is used. </td></tr>
    <tr><td class="paramname">inputFile</td><td>Path to the input file. Used only if locations and distances are provided. </td></tr>
    <tr><td class="paramname">outputFile</td><td>Path to the output file. Used only if locations and distances are provided.</td></tr>
  </table>
  </dd>
</dl>
<p>This method initializes a graph and uses a parser to read data from the specified files. If any of the file paths are empty, it defaults to using predefined file paths for small data and input/output files. </p>

</div>
</div>
<a id="a776d320110110bd63592b09990d72709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776d320110110bd63592b09990d72709">&#9670;&nbsp;</a></span>ecoFriendlyRoute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::ecoFriendlyRoute </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the Eco-friendly route planning functionality in the command-line interface. </p>
<p>This method allows the user to specify a source and destination node, nodes and edges to avoid, a maximum walking time, and whether to compute an approximate path or not. The results are output to the provided output stream. The results can go to either a file or standard console out. After execution, the user is returned to the main menu.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Reference to the graph that represents map. </td></tr>
    <tr><td class="paramname">outFile</td><td>Place where the results will be writen, can be a file or just standard console out. </td></tr>
    <tr><td class="paramname">locations</td><td>A string representing the file path for a formated .csv file containing Location/Node data. </td></tr>
    <tr><td class="paramname">distances</td><td>A string representing the file path for a formated .csv file containing Distance/Edge data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a848f524b478f02655dc71fc52b784364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848f524b478f02655dc71fc52b784364">&#9670;&nbsp;</a></span>independantRoute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::independantRoute </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the independent route planning functionality in the command-line interface. </p>
<p>This method prompts the user to input a source and destination node, validates the input, and computes the shortest route between the 2 without restrictions, and, if possible, a second completely disjoint route as an alternative. The results can go to either a file or standard console out. After execution, the user is returned to the main menu.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Reference to the graph that represents map. </td></tr>
    <tr><td class="paramname">outFile</td><td>Place where the results will be writen, can be a file or just standard console out. </td></tr>
    <tr><td class="paramname">locations</td><td>A string representing the file path for a formated .csv file containing Location/Node data. </td></tr>
    <tr><td class="paramname">distances</td><td>A string representing the file path for a formated .csv file containing Distance/Edge data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e43cfaeb12d2d2077359c09eacfcf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e43cfaeb12d2d2077359c09eacfcf30">&#9670;&nbsp;</a></span>outPutEcoResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::outPutEcoResult </td>
          <td>(</td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>sNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>dNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nAvoid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Edge&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>eAvoid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>maxWalkTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>aprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the eco-friendly route planning results based on the given parameters. </p>
<p>This method calculates and outputs the best eco-friendly route from a source node to a destination node, considering parking nodes, walking time, and driving time. It uses Dijkstra's algorithm to compute the shortest paths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sNode</td><td>Pointer to the source node. </td></tr>
    <tr><td class="paramname">dNode</td><td>Pointer to the destination node. </td></tr>
    <tr><td class="paramname">nAvoid</td><td>Vector of nodes to avoid during the route calculation. </td></tr>
    <tr><td class="paramname">eAvoid</td><td>Vector of edges to avoid during the route calculation. </td></tr>
    <tr><td class="paramname">maxWalkTime</td><td>Maximum allowed walking time in minutes. </td></tr>
    <tr><td class="paramname">aprox</td><td>Boolean flag indicating whether to allow approximate routes if none exist in the given maxWalkTime. </td></tr>
    <tr><td class="paramname">g</td><td>Pointer to the graph object representing the network. </td></tr>
    <tr><td class="paramname">outFile</td><td>Output stream to write the results.</td></tr>
  </table>
  </dd>
</dl>
<p>Dijkstra's shortest path algorithm dominates the time complexity of this method. The overall time complexity is O(V^2), where V is the number of vertices in the graph. </p>

</div>
</div>
<a id="a080d8feec666613c85e66f5dbe562f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080d8feec666613c85e66f5dbe562f9e">&#9670;&nbsp;</a></span>outPutIndependentResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::outPutIndependentResult </td>
          <td>(</td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>sNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>dNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the independent route planning results based on the given parameters.. </p>
<p>This method processes the query result and writes it to the specified output file. It takes the query name, source and destination nodes, the graph, and the output file stream as input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sNode</td><td>A pointer to the source node involved in the query. </td></tr>
    <tr><td class="paramname">dNode</td><td>A pointer to the destination node involved in the query. </td></tr>
    <tr><td class="paramname">g</td><td>A pointer to the graph object containing the nodes and edges. </td></tr>
    <tr><td class="paramname">outFile</td><td>A reference to the output file stream where the result will be written.</td></tr>
  </table>
  </dd>
</dl>
<p>Dijkstra's shortest path algorithm dominates the time complexity of this method. The overall time complexity is O((V + E) log V), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="aff62b6a34249f957b6002c948f3212bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff62b6a34249f957b6002c948f3212bd">&#9670;&nbsp;</a></span>outputPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::outputPath </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to aid in writing the path to the output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector of node IDs representing the path. </td></tr>
    <tr><td class="paramname">out</td><td>The output stream to write the path to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa799e5075fdf9a550e8e5436341ab527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa799e5075fdf9a550e8e5436341ab527">&#9670;&nbsp;</a></span>outPutRestrictedResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::outPutRestrictedResult </td>
          <td>(</td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>sNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>dNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nAvoid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Edge&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>eAvoid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>must</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the result of a restricted path query operation to a file or standard cout. </p>
<p>This method calculates and outputs the best eco-friendly route from a source node to a destination node and some restrictions like nodes and edges to avoid, and a node that must be included. It uses Dijkstra's algorithm to compute the shortest path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sNode</td><td>A pointer to the source node involved in the query. </td></tr>
    <tr><td class="paramname">dNode</td><td>A pointer to the destination node involved in the query. </td></tr>
    <tr><td class="paramname">nAvoid</td><td>A vector of pointers to nodes that should be avoided in the path. </td></tr>
    <tr><td class="paramname">eAvoid</td><td>A vector of pointers to edges that should be avoided in the path. </td></tr>
    <tr><td class="paramname">must</td><td>A pointer to a node that must be included in the path. </td></tr>
    <tr><td class="paramname">g</td><td>A pointer to the graph object containing the nodes and edges. </td></tr>
    <tr><td class="paramname">outFile</td><td>A reference to the output file stream where the result will be written.</td></tr>
  </table>
  </dd>
</dl>
<p>Dijkstra's shortest path algorithm dominates the time complexity of this method. The overall time complexity is O((V + E) log V), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="a358a9b97ca9295425be3e4095c3b6e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358a9b97ca9295425be3e4095c3b6e70">&#9670;&nbsp;</a></span>presentUI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLInterface::presentUI </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Presents a user interface for selecting different planning modes. </p>
<p>This method initializes a graph and parses location and distance data from the provided file paths. If the file paths are empty, it defaults to parsing data from predefined data files. The user is then presented with a menu to choose between three planning modes: Independent Planning, Restricted Planning, and Eco-Friendly Planning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locations</td><td>The file path to the locations data. If empty, default file is used. </td></tr>
    <tr><td class="paramname">distances</td><td>The file path to the distances data. If empty, default file is used. </td></tr>
    <tr><td class="paramname">outFile</td><td>The output stream where results will be written. If empty, defaults to standard console out(std::cout).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, non-zero otherwise. </dd></dl>

</div>
</div>
<a id="a5ada6e7711678bf1f038a0f18ffd5e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ada6e7711678bf1f038a0f18ffd5e80">&#9670;&nbsp;</a></span>restrictedRoute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLInterface::restrictedRoute </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the restricted route planning functionality in the command-line interface. </p>
<p>This method allows the user to specify a source node, a destination node, nodes to avoid, edges to avoid, and an optional node that must be included in the route. It then calculates and outputs the shortest path between the source and destination nodes following all the restrictions. The results can go to either a file or standard console out. After execution, the user is returned to the main menu.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Reference to the graph that represents map. </td></tr>
    <tr><td class="paramname">outFile</td><td>Place where the results will be writen, can be a file or just standard console out. </td></tr>
    <tr><td class="paramname">locations</td><td>A string representing the file path for a formated .csv file containing Location/Node data. </td></tr>
    <tr><td class="paramname">distances</td><td>A string representing the file path for a formated .csv file containing Distance/Edge data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="CLInterface_8h_source.html">CLInterface.h</a></li>
<li>src/<a class="el" href="CLInterface_8cpp.html">CLInterface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
